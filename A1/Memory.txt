1. The program will print "not equal". &a == b compares the address of the local variable a to the address of x.
2. The program will probably print "equal". func1 and func2 declare local variables and then return their addresses, but because upon returning from func1, x is no longer in scope, func2 assigns it the same address space unless something else has done that already. 
3. No. q was not allocated with new or malloc() and is on the stack, so trying to free it will result in an error.
4. Yes. Freeing p is correct as it was allocated on the heap, and making q null allows something else to be placed there on the stack. (this assumes that when nulling something on the stack, the stack pointer is automatically incremented)
5. X prints 0. On the Trottier computers with g++(v5.4), 10 empty bytes are pushed for name on the stack, and then 4 more bytes are pushed for x. Because the stack grows down but arrays are really just positive offset values from the pointer, when excess data from cin>>name is entered, it doesn't overflow into x, but whatever is before it in the stack is affected.

However, my machine (macOS using g++(v6.3)) appears to allocate space at compile time (.data? section? implying heap...) such that if name begins at 0x00, x will be at 0x0C. I initially assumed this might be a buffer, but when additional ints were added the supposed buffer rule was ignored unless the ints would have to occupy the same space in memory, at which point the allocation of name was moved to an earlier block by 0x10. It seems as though name always is located at a block starting at a multiple of 16d. This means that when prompted for your name, if you enter "1234567891000", x will equal 48.
